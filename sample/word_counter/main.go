// Code generated by tlex. DO NOT EDIT.

package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
)

var nc = 0
var nw = 0
var nl = 0

type yyStateID = int
type yyRegexID = int

var YYText string

var (
	ErrYYScan = errors.New("failed to scan")
)

// state id to regex id
var yyStateIDToRegexID = []yyRegexID{
	0, // state 0 „ÅØ BH state
	1,
	2,
	1,
	3,
}

var yyFinStates = map[yyStateID]struct{}{
	1: {},
	2: {},
	3: {},
	4: {},
}

var yyTransitionTable = map[yyStateID]map[byte]yyStateID{
	1: {
		9:   2,
		10:  4,
		13:  2,
		32:  2,
		40:  3,
		41:  3,
		48:  3,
		49:  3,
		50:  3,
		51:  3,
		52:  3,
		53:  3,
		54:  3,
		55:  3,
		56:  3,
		57:  3,
		65:  3,
		66:  3,
		67:  3,
		68:  3,
		69:  3,
		70:  3,
		71:  3,
		72:  3,
		73:  3,
		74:  3,
		75:  3,
		76:  3,
		77:  3,
		78:  3,
		79:  3,
		80:  3,
		81:  3,
		82:  3,
		83:  3,
		84:  3,
		85:  3,
		86:  3,
		87:  3,
		88:  3,
		89:  3,
		90:  3,
		97:  3,
		98:  3,
		99:  3,
		100: 3,
		101: 3,
		102: 3,
		103: 3,
		104: 3,
		105: 3,
		106: 3,
		107: 3,
		108: 3,
		109: 3,
		110: 3,
		111: 3,
		112: 3,
		113: 3,
		114: 3,
		115: 3,
		116: 3,
		117: 3,
		118: 3,
		119: 3,
		120: 3,
		121: 3,
		122: 3,
	},
	2: {
		9:  2,
		13: 2,
		32: 2,
	},
	3: {
		40:  3,
		41:  3,
		48:  3,
		49:  3,
		50:  3,
		51:  3,
		52:  3,
		53:  3,
		54:  3,
		55:  3,
		56:  3,
		57:  3,
		65:  3,
		66:  3,
		67:  3,
		68:  3,
		69:  3,
		70:  3,
		71:  3,
		72:  3,
		73:  3,
		74:  3,
		75:  3,
		76:  3,
		77:  3,
		78:  3,
		79:  3,
		80:  3,
		81:  3,
		82:  3,
		83:  3,
		84:  3,
		85:  3,
		86:  3,
		87:  3,
		88:  3,
		89:  3,
		90:  3,
		97:  3,
		98:  3,
		99:  3,
		100: 3,
		101: 3,
		102: 3,
		103: 3,
		104: 3,
		105: 3,
		106: 3,
		107: 3,
		108: 3,
		109: 3,
		110: 3,
		111: 3,
		112: 3,
		113: 3,
		114: 3,
		115: 3,
		116: 3,
		117: 3,
		118: 3,
		119: 3,
		120: 3,
		121: 3,
		122: 3,
	},
}

func yyNextStep(id yyStateID, b byte) yyStateID {
	if mp, ok := yyTransitionTable[id]; ok {
		return mp[b]
	}

	return 0
}

type yyLexer struct {
	rs          io.ReadSeeker
	beginPos    int
	finPos      int
	currPos     int
	finRegexID  int
	currStateID yyStateID
	YYText      string
}

func New(rs io.ReadSeeker) *yyLexer {
	return &yyLexer{
		rs:          rs,
		beginPos:    0,
		finPos:      0,
		currPos:     0,
		finRegexID:  0,
		currStateID: 1, // init state id is 1.
	}
}

func (yylex *yyLexer) currByte() (byte, error) {
	b := make([]byte, 1)
	if _, err := yylex.rs.Read(b); err != nil {
		return 0, err
	}
	if _, err := yylex.rs.Seek(int64(yylex.currPos), io.SeekStart); err != nil {
		return 0, err
	}

	return b[0], nil
}

func (yylex *yyLexer) Next() (int, error) {
	yyEofCnt := 0
yystart:
	for {
		yyb, err := yylex.currByte()
		if err != nil {
			if errors.Is(err, io.EOF) {
				yyEofCnt++
				if yyEofCnt == 1 {
					goto finProcess
				}
			}
			return 0, err
		}
	finProcess:
		yyNxStID := yyNextStep(yylex.currStateID, yyb)
		if yyNxStID == 0 {
			yydata := make([]byte, yylex.finPos+1-yylex.beginPos)
			if _, err := yylex.rs.Seek(int64(yylex.beginPos), io.SeekStart); err != nil {
				return 0, err
			}
			if _, err := yylex.rs.Read(yydata); err != nil {
				return 0, err
			}
			yylex.YYText = string(yydata)
			YYText = yylex.YYText
			yyNewCurrPos := yylex.finPos + 1
			yylex.beginPos = yyNewCurrPos
			yylex.finPos = yyNewCurrPos
			yylex.currPos = yyNewCurrPos
			yylex.currStateID = 1

			regexID := yylex.finRegexID
			yylex.finRegexID = 0
			switch regexID {
			case 0:
				return 0, ErrYYScan
			case 1:
				{
					nc += len(YYText)
					nw++
				}
				goto yystart
			case 2:
				{
					nc++
				}
				goto yystart
			case 3:
				{
					nl++
					nc++
				}
				goto yystart

			default:
				return 0, ErrYYScan
			}
		}
		if _, ok := yyFinStates[yyNxStID]; ok {
			yylex.finPos = yylex.currPos
			yylex.finRegexID = yyStateIDToRegexID[yyNxStID]
		}
		yylex.currStateID = yyNxStID
		yylex.currPos++
		if _, err := yylex.rs.Seek(int64(yylex.currPos), io.SeekStart); err != nil {
			return 0, err
		}
	}

	return 0, io.EOF
}

// This part is optional
func main() {
	program := `hello world
hello tlex
`
	fmt.Print(program)
	fmt.Println("-----------------")

	lex := New(bytes.NewReader([]byte(program)))
	for {
		_, err := lex.Next()
		if err != nil {
			break
		}
	}
	fmt.Printf("number of lines: %d\n", nl)
	fmt.Printf("number of words: %d\n", nw)
	fmt.Printf("number of chars: %d\n", nc)
}
